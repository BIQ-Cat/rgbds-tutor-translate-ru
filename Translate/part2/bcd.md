# Десятичные числа

Раз уж игрок умеет разрушать блоки, его за это стоит вознаграждать, например, очками.
Мы будем начинать с нуля и присваивать одно очко за каждый разбитый блок.
Счет будем отображать на панели слева. 

## BCD

Поскольку мы несколько ограничены в использовании памяти, мы выделим для хранения счёта всего один байт. Существует множество способов чтения и записи десятичных чисел, но в этот раз мы воспользуемся так называемым "Packed Binary Coded Decimal" (Упакованный двоично-десятичный код) или packed BCD.

BCD позволяет нам работать с десятичными числами в байтах, не используя A-F, так что вместо $A мы будем писать 10, вместо $B - 11 и т.д.

Помните, как работают системы счисления? Не [забывайте освежать свою память], если вы испытывайте с ними сложности.

"Упакованный" означает, что мы "упаковываем" 2 цифры в 1 байт. Байт состоит из 8 бит, и в 4 битах мы уже можем хранить числа от `$0` (`%0000`) до `$F` (`%1111`), чего более чем достаточно для хранения чисел от 0 до 9.

Например, число 35 (номер моего любимого покемона) содержит цифру 3 `%0011` и 5 `%0101`. Байт, в котором "упаковано" это число, будет выглядить так: `%00110101`.

## Подсчет очков

Для начала определим глобальную переменную для хранения счёта:

```rgbasm,linenos,start={{#line_no_of "" ../../unbricked/bcd/main.asm:score-variable}}
{{#include ../../unbricked/bcd/main.asm:score-variable}}
```

Затем зададим ей нулевое значение в том же месте, где мы инициализировали другие глобальные переменные:

```rgbasm,linenos,start={{#line_no_of "" ../../unbricked/bcd/main.asm:init-variables}}
{{#include ../../unbricked/bcd/main.asm:init-variables}}
```

Теперь мы напишем функцию для увеличения количества очков и разместим ее сразу после `IsWallTile`.
Пока не обращайте внимания на вызов `UpdateScoreBoard`: мы поговорим о написании этой функции чуть позже.

```rgbasm,linenos,start={{#line_no_of "" ../../unbricked/bcd/main.asm:increase-score}}
{{#include ../../unbricked/bcd/main.asm:increase-score}}
```

Давайте посмотрим, что происходит в функции:
`xor a` - это неявное `xor a, a`. Эта операция обнуляет `a` и очищает флаг carry.
Затем мы прибавляем к `a` сначала 1, а затем текущий счёт, хранящийся в `wScore`, тем самым получив обновлённый счет.

Пока хорошо идём, но есть один нюанс: что если наш счёт перевалит за первый десяток? Процессор умеет считать только в бинарном формате, поэтому он выдаст следующее:

`%00001001` + `%00000001` = `%00001010` = `$A`

Это шестнадцатеричное представление числа 10, и нам нужно его чуть скорректировать, чтобы получить десятичное. Именно этим занимается `daa` (англ. "Decimal Adjust after Addition", "десятичная коррекция после сложения")
После выполнения `daa` значение в аккомуляторе будет изменено с `%00001010` на `%00010000`: в первом ниббле будет 1, а во втором 0. [Здесь](https://blog.ollien.com/posts/gb-daa/) вы можете найти больше информации о работе `DAA` в Game boy (на английском языке).

Затем мы сохраняем счёт обратно в `wScore` и, наконец, вызываем функцию, которая обновит счёт на экране и реализацией которой мы займёмся совсем скоро.

Счёт должен увеличиваться только после разрушения блока. Чтобы достичь этого, добавим инструкцию `call IncreaseScorePackedBCD` после обработки коллизии блоков (имеется ввиду коллизия **и с левым, и правым тайлом блока**) в `CheckAndHandleBrick`. 

```rgbasm,linenos,start={{#line_no_of "" ../../unbricked/bcd/main.asm:check-for-brick}}
{{#include ../../unbricked/bcd/main.asm:check-for-brick}}
```

## Тайлы цифр

Перед тем, как мы сможем отобразить наш счет, нам необходимо добавить графическое представление цифр 0-9. У нас уже имеются тайлы для этого проекта в [данном файле](https://github.com/gbdev/gb-asm-tutorial/raw/master/unbricked/bcd/digit-tileset.asm). Вставьте информацию прямо перед меткой `TilesEnd`. Код должен выглядить вот так:

![Screenshot of tile set with digits added at the end](../assets/part2/img/bcd-tileset.png)

Чтобы облегчить себе работу с тайлами цифр, добавим константу `DIGIT_OFFSET`, хранящую id первого тайла с цифрой: $1A.

```rgbasm,linenos,start={{#line_no_of "" ../../unbricked/bcd/main.asm:digit-offset}}
{{#include ../../unbricked/bcd/main.asm:digit-offset}}
```

Давайте допустим, что наш счет не может превысить 99 ([ведь что може в теории пойти не так](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D0%B0_2000_%D0%B3%D0%BE%D0%B4%D0%B0)?), поэтому двух цифр нам будет достаточно.

В начале мы можем отобразить 2 нуля (тайл с id `$1A`). Давайте разместим их на третей строке, начиная с 4 тайлов слева.
Вы можете найти уже измененный tilemap [здесь](https://github.com/gbdev/gb-asm-tutorial/raw/master/unbricked/bcd/tilemap.asm)

На старте игра должна выглядить вот так:

![Screenshot of tile map with two zeroes added](../assets/part2/img/bcd-tilemap.png)

> **Tip:** Вы можете найти адрес тайла внутри VRAM в tile map viewer'е вашего эмулятора.
> Скриншот выше был сделан в emulucious.

Давайте запишем их местонахождение, введя константу с локацией тайла десятков и единиц в начале нашего файла, перед другими константами.

```rgbasm,linenos,start={{#line_no_of "" ../../unbricked/bcd/main.asm:score-tile-location}}
{{#include ../../unbricked/bcd/main.asm:score-tile-location}}
```
## Показ счёта

Теперь нам осталось лишь написать недостающую функцию `UpdateScoreBoard`, которая будет выводить текущий счет на экран.

```rgbasm,linenos,start={{#line_no_of "" ../../unbricked/bcd/main.asm:update-score-board}}
{{#include ../../unbricked/bcd/main.asm:update-score-board}}
```

Сперва нам нужно скопировать текущий счёт из `wScore` в регистр `a`. Вспомним, что счёт хранится в формате BCD, где каждый ниббл содержит десятичную цифру. 

Инструкция `and %11110000` убирает младший ниббл, заменяя его нулями, поэтому теперь в аккомуляторе хранится только старший ниббл.

`swap a` позволяет нам поменять нибблы местами, тем самым давая нам беспрепятственный доступ к разряду десятков (грубо говоря, этой инструкцией мы удаляем нули в разряде единиц).

Чтобы получить из числа ID тайла с цифрой, нам нужно прибавить к нему константу `DIGIT_OFFSET`. Полученный таким образом тайл мы сохраняем в `SCORE_TENS` - участок тайлмапа, записанного в VRAM. Это действие заменяет тайл на нужный нам, показывая разряд десятков на экране.

И наконец, повторим этот процесс для младшего ниббла: мы убираем старший ниббл с помощью маски `%00001111`. Так как нули теперь находятся в начале, а не в конце, менять нибблы местами не нужно.

Теперь мы может отобразить счет на экране! Нам нужно вызывать `UpdateScoreBoard` каждый раз, когда счет обновляется. Мы уже это реализовали в функции `IncreaseScorePackedBCD`.
