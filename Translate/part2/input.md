# Ввод

У нас есть все компоненты игры, кроме ввода игрока.
Программа играет сама себя, давайте изменим это.

Вставьте этот код под циклом `Main`.
Как и `Memcpy`, это функция, которая может быть использована в разных местах с помощью `call`.

```rgbasm,linenos,start={{#line_no_of "" ../../unbricked/input/main.asm:input-routine}}
{{#include ../../unbricked/input/main.asm:input-routine}}
```

Как вы видите, чтение ввода на Game Boy реализовано очень сложно, на данном этапе будет трудно объяснить принцип его работы.
Давайте представим, что функция волшебным образом _понимает_, что вы нажали.
Поняли? Отлично.

Теперь, раз мы знаем, как использовать функции, давайте вызовем `UpdateKeys` для чтения ввода игрока.
`UpdateKeys` записывает нажатые клавиши в блок памяти под названием `wCurKeys`, который мы можем прочесть, когда функция завершает работу.
Из-за этого мы можем считывать ввод только каждый кадр.

Это очень важно, потому что мы не можем считывать нажатия слишком часто.

Первым делом, давайте зарезервируем место для двух переменных, которые использует `UpdateKeys`; вставьте это в конец `main.asm`:

```rgbasm,linenos,start={{#line_no_of "" ../../unbricked/input/main.asm:vars}}
{{#include ../../unbricked/input/main.asm:vars}}
```

Каждая переменная должна находиться в RAM, а не в ROM, потому что мы не можем записывать в последний (Read-Only Memory).
Также, каждая переменная требует 1 байт, поэтому мы можем использовать `db` ("Define Byte") для его резервирования.

Мы используем `and`, который нужен для изменения флага `z` на логическое значение.
Можно задействовать константы `PADF` для чтения конкретного ключа.

```rgbasm,linenos,start={{#line_no_of "" ../../unbricked/input/main.asm:main}}
{{#include ../../unbricked/input/main.asm:main}}
```

Теперь, если вы скомпилируете проект, то сможете двигать ракетку с помощью d-pad!
Ура, у нас появились зачатки игры!
