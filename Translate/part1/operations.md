# Операции и флаги

Хорошо, мы знаем, как передавать значения, но просто копировать числа - это не весело; мы хотим их изменять!

Процессор GB не обеспечивает наличие всех операций (например, нет инструкции умножения), но мы можем просто запрограммировать их сами с помощью того, что у нас есть.
Давайте поговорим о некоторых операциях, которые он *имеет* (я пока опущу некоторые из них, которые не используются в Hello World).

## Арифметика

Простейшими арифметическими командами, поддерживаемыми процессором, являются `inc` и `dec`, которые увеличивают и уменьшают свой операнд соответственно.
(Если вы не знали, "to increment" означает "добавить 1", а "to decrement" означает "вычесть 1".)
Так, например, `dec bc` в строке {{#line_no_of "^\s*dec bc" ../assets/hello-world.asm}} из `hello-world.asm` просто вычитает 1 из `bc`.

Ладно, круто!
Но не могли бы мы прибавлять/убавлять больше, чем 1?
Конечно, можем, с помощью `add` и `sub`!
Они соответственно добавляют(ADD) и вычитают(SUBtract) произвольные значения (либо константу, либо регистр).
Ни то, ни другое не используется в руководстве, но младшим братом `sub` является "cp". Он находится в строке {{#line_no_of "^\s*cp\b" ../assets/hello-world.asm}}.
`cp` позволяет сравнивать(to ComPare) значения.
`cp` работает так же, как и `sub`, но он отбрасывает результат вместо того, чтобы записывать его обратно.
"Подожди, так он ничего не делает?" - вы можете спросить. Нет, он обновляет **флаги**.

## Флаги

Пришло время поговорить о регистре специального назначения (помните его?) `f`, для, *флагов*.
Регистр `f` содержит 4 бита, называемые "флагами", которые обновляются в зависимости от результатов операции.
Этими 4 битами являются:

Имя  | Описание
-----|---------------------
  Z  | Zero flag (флаг нуля)
  N  | Addition/subtraction (сложение/вычитание)
  H  | Half-carry (недоперенос)
  C  | Carry (перенос)

Да, есть флаг с именем "C" и регистр с именем "c", и **это разные, не связанные между собой вещи**.
На первый взгляд, это делает синтаксис немного запутанным, но они всегда используются в разных контекстах, так что все в порядке.

Мы пока не будем трогать N и H; давайте сосредоточимся на Z и C.
Z - это самый простой флаг: он устанавливается, когда результат операции равен 0, и сбрасывается в противном случае.
C устанавливается, когда операция *переполняется*(overflows) или *опускается ниже нуля*(underflows).

Что такое переполнение?
Давайте возьмем простую инструкцию `add a, 42`.
Она просто добавляет 42 к содержимому регистра `a` и записывает результат обратно в `a`.

```rgbasm
    ld a, 200
    add a, 42
```

В конце этого фрагмента `a` равно 200 + 42 = 242, отлично!
Но что, если я запишу этот пример следующим образом?

```rgbasm
    ld a, 220
    add a, 42
```

Ну, можно было бы подумать, что `a` будет равно 220 + 42 = 262, но это было бы неверно.
Помните, что `a` - это 8-битный регистр, *он может хранить только восемь бит информации*!
И если бы мы записали 262 в двоичном формате, мы получили бы %100000110, для чего требуется не менее 9 бит...
Так что же происходит?
Просто этот девятый бит *теряется*, и значение, которое мы получаем в итоге, равно %00000110 = 6.
Это называется *overflow*: после **добавления** мы получаем значение **меньшее**, чем то, с которого мы начали.

Мы также можем получить аналогичный результат, используя `sub`, и, например, вычесть 42 из 6; как мы знаем, для всех `X` и `Y`, `X + Y - Y = X`, и мы только что видели, что 220 + 42 = 6 (кстати, это называется *арифметика по модулю 256*); так что, 6 - 42 = (220 + 42) - 42 = 220.
Это называется *underflow*: после **вычитания** мы получаем значение **большее**, чем то, с которого мы начали.

Если во время операции произошел overflow или underflow, устанавливается флаг *Carry*, в противном случае этот флаг сбрасывается.
(Однако, как мы увидим позже, не все операции обновляют флаг *Carry*.)

::: tip В итоге

- Мы можем складывать и вычитать числа.
- Флаг Z позволяет нам узнать, был ли результат равен 0.
- Регистры могут хранить только ограниченный диапазон целых чисел.
- Выход за пределы этого диапазона называется **overflow** или **underflow** для сложения и вычитания соответственно.
- Флаг C сообщает нам, произошло ли что-либо из этого.

:::

## Сравнение

Теперь давайте подробнее поговорим о том, как `cp` используется для сравнения чисел.
Напомню: `cp` вычитает свой операнд из `a` и соответствующим образом обновляет флаги, но не записывает результат обратно.
Мы можем использовать флаги для проверки свойств сравниваемых значений, и в следующем уроке мы увидим, как именно.

Проще всего работать с флагом Z.
Если он установлен, мы знаем, что вычитание дало 0, т.е. `a - операнд == 0`; следовательно, `a == операнд`!
Если он не установлен, что ж, тогда мы знаем, что `a != операнд`.

Проверка на равенство - это хорошо, но мы также можем захотеть выполнить *сравнения*.
Для этого как раз и нужен флаг С.
Видите ли, при выполнении вычитания флаг переноса устанавливается, когда результат опускается ниже 0 — то есть просто становится отрицательным!

Итак, когда устанавливается carry флаг, мы знаем, что `a - операнд < 0`, следовательно, что `a < операнд`..!
И, наоборот, мы знаем, что если он *не* установлен, то `a >= операнд`.
Отлично!

## Краткое изложение урока

Инструкция  |Мнемоника | Эффект
------------|----------|---------------------------------------------
Add         | `add`    | Добавляет значения к `a`
Subtract    | `sub`    | Вычитает значения из `a`
Compare     | `cp`     | Сравнивает значения с тем, что содержится в `a`
